cromfs - Copyright (C) 1992,2006 Bisqwit (http://iki.fi/bisqwit/)
License: GPL
Homepage: http://bisqwit.iki.fi/source/cromfs.html

cromfs filesystem structure / format description.

--------------------------------
Note: Inode 1 is assumed to be the root directory by the kernel.

Note: All integers are encoded in little-endian byte order.

OVERALL STRUCTURE

OBJECT: SUPERBLOCK
	0000	u64	CROMFS SIGNATURE "CROMFS01"
	0008	u64	Location of BLKDATA within the filesystem
	0010	u64	Location of FBLKTAB within the filesystem (must be last)
	0018	u64	Location of the Inotab inode within the filesystem
	0020	u64	Location of the Root directory within the filesystem
	0028	u32	FSIZE Maximum size of uncompressed FBLOCK (default: 2M)
	002C	u32	BSIZE Size of uncompressed blocks (default: 64k)
	0030	u64	Bytes of file data on disk (only there for statvfs)
	0...	INODE	Root directory
	0...	INODE	Inotab (only the "list of blocks" is used)
	0...	BLKDATA	LZMA-compressed array of BLOCK entries.
	0...	FBLOCK[] FBLKTAB = compressed storage

(Note: The rootdir and inotab inodes could also be compressed...
 especially inotab could be worthwhile. It may contain a long
 list of blocks. It could be considered for a future version.)

---------------------------

STRUCT: FBLOCK
	0000	u32	length of compressed data
	0004	char[]	LZMA-compressed data, length indicated in above field
	0009	u64	length of uncompressed data (this field is part of the LZMA stream)
	(Note: Since cromfs version 1.0.5, FBLOCKs are variable-length.
	 Previously they were all of FSIZE size.)
	(Note: Since cromfs version 1.1.0, FSIZE indicates the maximum size of
	 uncompressed FBLOCKs. Previously it indicated the maximum size of compressed
	 FBLOCKs.)

STRUCT: BLKDATA (LZMA-compressed)
	0000	BLOCK[]  BLKTAB = all blocks of the filesystem (indexed by block number)
	(Note: To handle BLKDATA effeciently, it must be decompressed entirely
	into the RAM when the block lists are needed. This typically might consume
	several megabytes of RAM. However, cromfs-driver deallocates the
	data periodically when the filesystem has been idle for some time.)

STRUCT: BLOCK
	0000	u32	FBLOCK number (0=first FBLOCK, 1=second FBLOCK, etc)
	0004	u32	starting offset within the _uncompressed data_ for this data
	(Note: different BLOCKs may utilize the same data from same FBLOCK.
	 They regions which they use may overlap partially or completely.
	 They do not need to be aligned.)
	(This record refers to at most BSIZE bytes of data, but may actually
	 refer to less data if this is the last block of the file.)

STRUCT: INODE
	0000	u32	mode
	0004	u32	mtime
	0008	u32	rdev, if a device, hardlink count otherwise
	000C	u16	uid
	000E	u16	gid
	0010	u64	size in bytes
	0018	u32[]	(data locators;indexes to BLKTAB, 0=first BLOCK,1=second BLOCK,...)
	(Note: Location of uid&gid and rdev have been changed in version 1.1.2)

STRUCT: ENTRY
	0000	u64	inode number
	0008	char[]	file name, nul-terminated

ALL FILES ARE COMPRESSED (the content is spread across different FBLOCKs)

FILE CONTENT WHEN: INOTAB
	0000	INODE[] all inodes of the filesystem (note: INODE is variable-length).
	                the beginning of each inode is at offset ((inodenumber-2) * 4)
	                inodenumber 1 is the root directory (not stored in INOTAB),
	                and inodenumber 0 is error.

FILE CONTENT WHEN: DIRECTORY
	0000	u32	number of files in directory
	0004	u32[]	index into each file entry (from directory entry beginning)
	0004	ENTRY[]	each file entry (variable length)

FILE CONTENT WHEN: SYMLINK
	0000	char[]	link text, not nul-terminated

FILE CONTENT WHEN: REGULAR FILES
	0000	content	file content

For other types of files, file has no content (size=0, blocktab=empty)

--------------------------------
Implementation help:

PROCEDURE To READ THE CONTENTS OF A FILE denoted by inode number N, do:
	Load the inode to get access to its list of blocks.
		If N = 0, use the INOTAB inode. (It is stored
		          in the filesystem uncompressed, raw.
		          You can find it by following the address
		          saved in the superblock.)
		If N = 1, use the rootdir inode. (Similarly.)
		If N > 1, first load the contents of INOTAB by calling
		          this function recursively with inode number 0.
		          Then load the inode from the INOTAB. (Of course,
		          you only need to read the portion of INOTAB that
		          contains this particular inode.)
	In the inode, for each block index [that needs to be processed in
	order to access this particular portion of the file], load that
	particular BLOCK from the decompressed BLKDATA, and then load
	the FBLOCK indicated by that BLOCK, decompress it, and copy
	the necessary number of bytes from that decompressed data,
	starting from the offset indicated in the BLOCK.
	(Of course, you do not need to decompress the same FBLOCK over
	and over again, but you can cache them. Caching is applicable
	to many of the steps in this task, but a cache needs RAM.)

PROCEDURE To LIST THE CONTENTS OF A DIRECTORY denoted by inode number N, do:
	Load the contents of the file denoted by inode number N, using the
	procedure described above.
	Then decode the content of the directory data using the format
	described above ("FILE CONTENT WHEN: DIRECTORY").
--------------------------------
